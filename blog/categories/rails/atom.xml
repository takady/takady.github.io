<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Yuichi Takada]]></title>
  <link href="http://blog.takady.net/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://blog.takady.net/"/>
  <updated>2017-02-19T19:22:05+09:00</updated>
  <id>http://blog.takady.net/</id>
  <author>
    <name><![CDATA[Yuichi Takada]]></name>
    <email><![CDATA[takadyuichi@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[rails の validation error message の i18n 対応]]></title>
    <link href="http://blog.takady.net/blog/2016/12/09/rails-validation-error-message-i18n/"/>
    <updated>2016-12-09T21:20:43+09:00</updated>
    <id>http://blog.takady.net/blog/2016/12/09/rails-validation-error-message-i18n</id>
    <content type="html"><![CDATA[<p>rails で Custom validatior や Custom validation method を定義して、その中で <code>errors.add</code> する際に、
message として使われる I18n のパスをどう書くのが良いのかっていうのが気になった。<br/>
結論としては、下記のように書くのがスッキリして良さそう。</p>

<h2>Custom Validators</h2>

<p>特定のモデルによらないエラーメッセージの場合は、下記のように <code>locales/en.yml</code> を書くことで、<code>record.errors.add(attribute, :something_invalid)</code>と書ける。</p>

<pre><code class="yml">en:
  errors:
    messages:
      something_invalid: Invalid something.
</code></pre>

<pre><code class="ruby">class MyCheckValidator &lt; ActiveModel::EachValidator
  def validate_each(record, attribute, value)
    unless check_something(value)
      record.errors.add(attribute, :something_invalid)
      #=&gt; record.errors.add(attribute, I18n.t('errors.messages.something_invalid')) と同じ
    end
  end

  def check_something(value)
   # Something
  end
end

class MyModel &lt; ActiveRecord::Base
  validates :name, my_check: true
end
</code></pre>

<h2>Custom Methods</h2>

<p>特定のモデルの特定の項目のエラーメッセージの場合は、下記のようにymlを書くことで、適切にメッセージを参照してくれる。</p>

<pre><code class="yml">en:
  activerecord:
    errors:
      models:
        my_model:
          attributes:
            start_date:
              cannot_be_after_end_date: It cannot be after the end date.
            end_date:
              cannot_be_before_start_date: It cannot be before the start date.
</code></pre>

<pre><code class="ruby">class MyModel &lt; ActiveRecord::Base
  validate :start_date_cannot_be_after_end_date, if: -&gt; { start_date.present? &amp;&amp; end_date.present? }

  private

  def start_date_cannot_be_after_end_date
    return if start_date &lt;= end_date

    errors.add(:start_date, :cannot_be_after_end_date)
    #=&gt; errors.add(:start_date, I18n.t('activerecord.errors.models.my_model.attributes.start_date.cannot_be_after_end_date')) と同じ
    errors.add(:end_date, :cannot_be_before_start_date)
    #=&gt; errors.add(:end_date, I18n.t('activerecord.errors.models.my_model.attributes.end_date.cannot_be_before_start_date')) と同じ
  end
end
</code></pre>

<h3>参考</h3>

<ul>
<li><a href="http://guides.rubyonrails.org/active_record_validations.html">Active Record Validations — Ruby on Rails Guides</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[rails で FormObject を使う]]></title>
    <link href="http://blog.takady.net/blog/2016/08/29/rails-form-object/"/>
    <updated>2016-08-29T19:38:49+09:00</updated>
    <id>http://blog.takady.net/blog/2016/08/29/rails-form-object</id>
    <content type="html"><![CDATA[<p>フォームでは日付の期間を入力し、それを日単位のレコードに保存するようなケースでは、FormObject を使えるかも。やってみた。</p>

<p><br /></p>

<p><img src="/images/2016-08-29-rails-form-object/screenshot1.png" alt="" /></p>

<p>こういうフォーム。</p>

<h1>Model</h1>

<p>uniqueness など Model 単位でバリデーションしなければいけないものや、コンテキストに関係なくバリデーションするものは Model に書く。</p>

<h2>app/models/foo_day.rb</h2>

<pre><code class="ruby">class FooDay &lt; ActiveRecord::Base
  belongs_to :user

  validates :user_id, presence: true
  validates :date, presence: true, uniqueness: {scope: :user_id}
end
</code></pre>

<h1>FormObject</h1>

<p>FormObject の参考では、よく <a href="https://github.com/solnic/virtus">virtus</a> を include しているサンプルがあるけど、Virtus の Type cast が効果的に使えそうなケース以外だと特に使わなくて良いかなと個人的に思った。<br/>
例えば今回のケースだと、view から文字列で渡ってくる <code>YYY-MM-DD</code> を Date に変換したかったので、一度 Virtus を使ってみたけど、
例えば <code>2016-08-32</code> のように Date として解釈できないものが渡ってきた場合に、エラーにならずに文字列のまま変数に格納される挙動だったので、あまり積極的に使う理由が無かった。<br/>
結局、日付の validation のために <a href="https://github.com/adzap/validates_timeliness">validates_timeliness</a> という gem を使ったけど便利だった。</p>

<h2>app/models/foo_day/registration_form.rb</h2>

<pre><code class="ruby">class FooDay::RegistrationForm
  include ActiveModel::Model

  attr_accessor :user_id, :from_date, :to_date

  validates :user_id, presence: true
  validates :from_date, presence: true, timeliness: {on_or_after: :today, type: :date}
  validates :to_date, allow_blank: true, timeliness: {on_or_after: :from_date, type: :date}

  def save
    return false unless valid?

    persist!
    true
  end

  private

  def foo_days
    @foo_days ||= build_foo_days
  end

  def build_foo_days
    if to_date.blank?
      [FooDay.new(date: from_date, user_id: user_id)]
    else
      (Date.parse(from_date)..Date.parse(to_date)).map {|date| FooDay.new(user_id: user_id, date: date) }
    end
  end

  def valid?
    return false unless super

    foo_days.each do |foo_day|
      next if foo_day.valid?

      foo_day.errors.full_messages.each do |message|
        errors.add(:base, I18n.t('activemodel.errors.invalid_foo_day', date: foo_day.date, message: message))
      end
    end

    return super
  end

  def persist!
    foo_days.each(&amp;:save!)
  end
end
</code></pre>

<h1>Controller</h1>

<h2>app/controllers/foo_days_controller.rb</h2>

<pre><code class="ruby">class FooDaysController &lt; ApplicationController
  def new
    @registration_form = FooDay::RegistrationForm.new
  end

  def create
    @registration_form = FooDay::RegistrationForm.new(params[:foo_day_registration_form].merge(user_id: current_user.id))

    if @registration_form.save
      redirect_to new_foo_day_path, notice: '登録に成功しました'
    else
      flash.now[:alert] = '登録に失敗しました'

      render action: :new
    end
  end
end
</code></pre>

<h1>View</h1>

<h2>app/views/foo_days/new.html.haml</h2>

<pre><code class="haml">.row
  %h1 日々の登録
  = form_for @registration_form, url: foo_days_path, method: :post do |f|
    - if @registration_form.errors.any?
      %ul
        - @registration_form.errors.full_messages.each do |msg|
          %li= msg

    = f.label '日付'
    = f.date_field :from_date
    %span 〜
    = f.date_field :to_date

    = f.submit '確定'
</code></pre>

<h1>Translation</h1>

<h2>config/locales/ja.yml</h2>

<pre><code class="yaml">ja:
  activemodel:
    attributes:
      foo_day/registration_form:
        from_date: 開始日
        to_date: 終了日
    errors:
      invalid_foo_day: '%{date} %{message}'
      models:
        foo_day/registration_form:
          attributes:
            from_date:
              on_or_after: は %{restriction} 以降の日付を指定してください
            to_date:
              on_or_after: は 開始日 以降の日付を指定してください
</code></pre>

<h1>まとめ</h1>

<p>フォームとモデルが1対1で対応しないケースもたまにあるので、その時は FormObject も選択肢の一つになるかも。</p>

<h1>参考</h1>

<ul>
<li><a href="http://webuild.envato.com/blog/creating-form-objects-with-activemodel-and-virtus/">Creating Form Objects with ActiveModel and Virtus - We build Envato</a></li>
<li><a href="http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/">7 Patterns to Refactor Fat ActiveRecord Models - Code Climate Blog</a></li>
<li><a href="http://qiita.com/quattro_4/items/6636efbf58cca13db02a">Form Object実装メモ - Qiita</a></li>
<li><a href="http://blog.enogineer.com/2014/12/02/rails-form-object/">Rails4でFormオブジェクトを作る際に気をつける3つのポイント｜江の島エンジニアBlog</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[rails で /users/:id ではなく /:username な routing にする方法]]></title>
    <link href="http://blog.takady.net/blog/2015/11/29/rails-routing-with-username-instead-of-id/"/>
    <updated>2015-11-29T23:06:56+09:00</updated>
    <id>http://blog.takady.net/blog/2015/11/29/rails-routing-with-username-instead-of-id</id>
    <content type="html"><![CDATA[<p>rails で普通に scaffold すると id が URL に入って <code>example.com/users/:id</code> となる。<br/>
これを <code>twitter.com/takady7</code> とか <code>github.com/takady</code> みたいにしたい時がある。<br/>
実現には 2 通りの方法があると思われる。</p>

<h1>to_param を使う方法</h1>

<p>activerecord に <a href="http://railsdoc.com/references/to_param">to_param</a> というメソッドがあって、これを使うと URL の :id の部分に id 以外を指定できるようになる。</p>

<h2>user.rb</h2>

<pre><code class="ruby">class User &lt; ActiveRecord::Base
  validates_presence_of :username
  validates_uniqueness_of :username, case_sensitive: false

  def to_param
    username
  end
end
</code></pre>

<h2>users_controller.rb</h2>

<pre><code class="ruby">class UsersController &lt; ApplicationController
  def show
    @user = User.find_by(username: params[:id])
  end
end
</code></pre>

<h2>routes.rb</h2>

<pre><code class="ruby">Rails.application.routes.draw do
  resources :users, path: '/', only: [:show, :edit, :update, :destroy]
end
</code></pre>

<pre><code>$ rake routes
    Prefix Verb   URI Pattern                        Controller#Action
 edit_user GET    /:id/edit(.:format)                users#edit
      user GET    /:id(.:format)                     users#show
           PATCH  /:id(.:format)                     users#update
           PUT    /:id(.:format)                     users#update
           DELETE /:id(.:format)                     users#destroy
</code></pre>

<h1>routing で param を設定する方法</h1>

<p>User クラスに to_param を定義せずに、 routes.rb で設定する方法。<br/>
<code>params[:username]</code> というふうに渡ってくるので、こちらの方が素直な気がして個人的にはこちらを使いたい。</p>

<h2>users_controller.rb</h2>

<pre><code class="ruby">class UsersController &lt; ApplicationController
  def show
    @user = User.find_by(username: params[:username])
  end
end
</code></pre>

<h2>routes.rb</h2>

<pre><code class="ruby">Rails.application.routes.draw do
  resources :users, param: :username, path: '/', only: [:show, :edit, :update, :destroy]
end
</code></pre>

<pre><code>$ rake routes
    Prefix Verb   URI Pattern                        Controller#Action
 edit_user GET    /:username/edit(.:format)          users#edit
      user GET    /:username(.:format)               users#show
           PATCH  /:username(.:format)               users#update
           PUT    /:username(.:format)               users#update
           DELETE /:username(.:format)               users#destroy
</code></pre>

<h1>参考</h1>

<ul>
<li><a href="http://stackoverflow.com/questions/7735315/rails-route-to-username-instead-of-id">ruby - Rails route to username instead of id - Stack Overflow</a></li>
<li><a href="http://railsdoc.com/references/to_param">to_param - リファレンス - - Railsドキュメント</a></li>
<li><a href="http://tnakamura.hatenablog.com/entry/2014/01/31/185214">Github みたいにパスの最初のセグメントでユーザー名を使う方法 - present</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[development環境だけbefore_actionをスキップする]]></title>
    <link href="http://blog.takady.net/blog/2014/12/03/skip-before-action-on-development-env/"/>
    <updated>2014-12-03T21:02:25+09:00</updated>
    <id>http://blog.takady.net/blog/2014/12/03/skip-before-action-on-development-env</id>
    <content type="html"><![CDATA[<p>最近railsでapi開発をしていて、もちろんテストコード書いてるんだけど、<br/>
たまにブラウザからGETリクエスト送ってサクッとjsonの中を見たいって時に、認証があって見れない。。。ってパターンがかなりある。<br/>
開発環境では、認証しなくていいやと思った。<br/>
下記のようにすることで、before_actionをdevelopment環境ではスキップさせられる。</p>

<pre><code class="ruby">class ApplicationController &lt; ActionController::Base
  before_action :authenticate unless Rails.env.development?

  def authenticate
    ...
  end
</code></pre>

<h1>参考</h1>

<p><a href="http://memo.yomukaku.net/entries/127">Rails.env.development?でdevelopment環境かどうかを判定できる - memo.yomukaku.net</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[railsでmysqlのbooleanなカラムをエイリアスで扱う時の注意事]]></title>
    <link href="http://blog.takady.net/blog/2014/12/02/rails-mysql-boolean/"/>
    <updated>2014-12-02T18:07:11+09:00</updated>
    <id>http://blog.takady.net/blog/2014/12/02/rails-mysql-boolean</id>
    <content type="html"><![CDATA[<p>rails+mysqlな環境では、booleanで定義したカラムはtinyint(1)で作られ、中身はtrue/falseではなく、0/1が入る。<br/>
そして、railsアプリケーション上でmysqlのtinyint(1)型データを扱う時、値は自動的にtrue/falseとして扱われる。<br/>
そこまでは知っていたんだけど、<code>select('foobar_flg as fb_flg')</code>というふうに、カラム名をエイリアスして取り出すと値が0/1なのは知らなかった。</p>

<p>具体的には下記のとおりである。</p>

<pre><code>pry(main)&gt; p = User.select(:foobar_flg)
  User Load (10.5ms)  SELECT  `users`.`foobar_flg` FROM `users`
=&gt; [#&lt;User id: nil, foobar_flg: false&gt;]
pry(main)&gt; p.first.foobar_flg
=&gt; false

pry(main)&gt; p = User.select('foobar_flg as fb_flg')
  User Load (5.8ms)  SELECT  foobar_flg as fb_flg FROM `users`
=&gt; [#&lt;User id: nil&gt;]
pry(main)&gt; p.first.fb_flg
=&gt; 0
</code></pre>

<p>ちなみに、selectメソッドの引数に文字列を指定したから0/1が返ってくるというわけではない。<br/>
下記のようにエイリアス無しなら、文字列で指定してもtrue/falseに解釈される。</p>

<pre><code>pry(main)&gt; p = User.select('foobar_flg')
  User Load (10.0ms)  SELECT  `users`.`foobar_flg` FROM `users`
=&gt; [#&lt;User id: nil, foobar_flg: false&gt;]
pry(main)&gt; p.first.foobar_flg
=&gt; false
</code></pre>

<p>このままだと結構困る。<br/>
結論としては、<strong>as使わない</strong>で済むならそれが最善手だと思う。<br/>
が、それが無理なら、例えば下記のようにModelのattributeメソッドをoverrideしちゃうのが良さそう。</p>

<pre><code class="ruby">def fb_flg
  read_attribute(:fb_flg) == 1
end
</code></pre>

<h1>参考</h1>

<p><a href="http://stackoverflow.com/questions/373731/override-activerecord-attribute-methods">ruby on rails - Override ActiveRecord attribute methods - Stack Overflow</a></p>
]]></content>
  </entry>
  
</feed>
