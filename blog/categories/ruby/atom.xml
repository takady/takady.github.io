<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Yuichi Takada]]></title>
  <link href="http://takady.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://takady.github.io/"/>
  <updated>2015-02-11T17:19:03+09:00</updated>
  <id>http://takady.github.io/</id>
  <author>
    <name><![CDATA[Yuichi Takada]]></name>
    <email><![CDATA[takadyuichi@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[apache_log-parserを修正してBenchmarkをとってみた]]></title>
    <link href="http://takady.github.io/blog/2015/02/11/apache-log-parser-benchmark/"/>
    <updated>2015-02-11T16:53:46+09:00</updated>
    <id>http://takady.github.io/blog/2015/02/11/apache-log-parser-benchmark</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/takady/apache_log-parser">takady/apache_log-parser</a></p>

<p>先週，とある機会に，とあるエンジニアの方が，僕が作った<a href="https://github.com/takady/apache_log-parser">apache_log-parser</a>というrubyのgemに対してアドバイスをしてくれた．<br/>
「parseメソッド呼ぶ度に毎回Patternクラスのインスタンスとか作ったりしてるけど，Parserをクラスにして，最初にインスタンス作る時に1回だけやるようにした方が効率良いよ」みたいな指摘だった．確かにその通りだった．指摘ありがとうございます！<br/>
ついでに，修正する前と後でパフォーマンスどれだけ良くなったのかを，rubyの標準ライブラリのBenchmarkを使って計測してみた．</p>

<p>benchmark.rb自体はこんな感じで，100万行parseするのにかかる時間を計測している．</p>

<pre><code class="ruby">$LOAD_PATH.unshift File.expand_path('../lib', __FILE__)
require 'apache_log/parser'
require 'benchmark'

common_line = '127.0.0.1 - - [20/May/2014:20:04:04 +0900] "GET /test/indx.html HTTP/1.1" 200 4576'
combined_line = '192.168.0.1 - - [07/Jun/2014:14:58:55 +0900] "GET /category/electronics HTTP/1.1" 200 128 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:9.0.1) Gecko/20100101 Firefox/9.0.1"'
customized_line = '192.168.0.1 - - [07/Feb/2011:10:59:59 +0900] "GET /x/i.cgi/net/0000/ HTTP/1.1" 200 9891 "-" "DoCoMo/2.0 P03B(c500;TB;W24H16)" virtualhost.example.jp "192.0.2.16794832933550" "09011112222333_xx.ezweb.ne.jp" 533593'

common_parser = ApacheLog::Parser.new('common')
combined_parser = ApacheLog::Parser.new('combined')
customized_parser = ApacheLog::Parser.new('combined', %w(vhost usertrack mobileid request_duration))

n = 1_000_000
Benchmark.bm(12) do |x|
  x.report('common:')     { (1..n).each{common_parser.parse(common_line)} }
  x.report('combined:')   { (1..n).each{combined_parser.parse(combined_line)} }
  x.report('customized:') { (1..n).each{customized_parser.parse(customized_line)} }
end
</code></pre>

<h2>Before</h2>

<p>まず，修正前のコードでのベンチマーク．</p>

<pre><code>$ ruby benchmark.rb
                   user     system      total        real
common:      125.630000   0.180000 125.810000 (125.889122)
combined:    151.530000   0.440000 151.970000 (152.090644)
customized:  186.610000   0.460000 187.070000 (187.200379)
</code></pre>

<h2>After</h2>

<p>次に，修正後のコードでのベンチマーク．</p>

<pre><code>$ ruby benchmark.rb
                   user     system      total        real
common:       20.770000   0.020000  20.790000 ( 20.797196)
combined:     30.090000   0.050000  30.140000 ( 30.161369)
customized:   40.240000   0.070000  40.310000 ( 40.388290)
</code></pre>

<p>めちゃくちゃ改善された！！</p>

<h1>参考</h1>

<p><a href="http://a-newcomer.com/29">RubyでのBenchmarkの取り方をば。</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[embulk-plugin-sqlite3を作った]]></title>
    <link href="http://takady.github.io/blog/2015/02/08/embulk-plugin-sqlite3/"/>
    <updated>2015-02-08T22:17:00+09:00</updated>
    <id>http://takady.github.io/blog/2015/02/08/embulk-plugin-sqlite3</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/takady/embulk-plugin-sqlite3">takady/embulk-plugin-sqlite3</a></p>

<h1>embulkとは</h1>

<p>いわゆるbulk loaderと言われる並列にデータを移動させるためのプロダクトの一つ．embulkがユニークなのはinput/outputなどの部分がpluggableになっている点．<br/>
つまり，データの移動に際して発生するリソースへの接続処理の実装や，データのクレンジング・フォーマット変換，その他必要になる雑多な処理をプラグインという形で定義しておくことで，再利用しやすくなるというわけ．</p>

<h2>Fluentdとの違い</h2>

<p>同じくTreasure Data社が開発しているFluentdも，input/outputのpluginをrubyで書けるなど，一見同じ感じである．<br/>
ただ，Fluentdのユースケースは<strong>リアルタイム</strong>にlogを流すという部分であり，一方でembulkは<strong>バッチ処理</strong>でデータをimport/exportする用途にフォーカスしているというところに違いがある．</p>

<h1>導入</h1>

<p><a href="https://github.com/embulk/embulk">embulkのREADME.md</a>にはjarをdownloadしてきて使う方法だけが書かれているが，普通にrubygems.orgにリリースされているので<code>gem install</code>で入れられる．</p>

<pre><code>$ gem install embulk
</code></pre>

<p>そして，<code>embulk gem install</code>でpluginをinstallする．</p>

<pre><code>$ embulk gem install embulk-plugin-sqlite3
Fetching: jdbc-sqlite3-3.8.7.gem (100%)
Successfully installed jdbc-sqlite3-3.8.7
Fetching: embulk-plugin-sqlite3-0.0.1.gem (100%)
Successfully installed embulk-plugin-sqlite3-0.0.1
2 gems installed
</code></pre>

<h1>実行</h1>

<p>今回はexampleのcsvファイルを，sqlite3のテーブルにloadしてみる.</p>

<p>下記で，exampleのcsvファイルを生成する．</p>

<pre><code>$ embulk example /tmp
$ embulk guess /tmp/example.yml -o /tmp/config.yml
</code></pre>

<p><code>/tmp/config.yml</code>のoutputの設定を下記のように修正する．</p>

<pre><code class="yaml">out:
  type: sqlite3
  database: '/tmp/test.db'
  table: 'load01'
</code></pre>

<p><code>embulk run</code>する．</p>

<pre><code>$ embulk run /tmp/config.yml
2015-02-08 22:29:38,623 [INFO]: main:org.embulk.standards.LocalFileInputPlugin: Listing local files with prefix '/tmp/csv'
2015-02-08 22:29:38,885 [INFO]: main:org.embulk.exec.LocalExecutor: Running 1 tasks using 8 local threads
2015-02-08 22:29:38,885 [INFO]: main:org.embulk.exec.LocalExecutor: {done:  0 / 1, running: 0}
2015-02-08 22:29:39,035 [INFO]: main:org.embulk.exec.LocalExecutor: {done:  1 / 1, running: 0}
Output finished. Commit reports = [{"records":4}]
2015-02-08 22:29:39,041 [INFO]: main:org.embulk.command.Runner: next config: {"in":{},"out":{}}
</code></pre>

<p>テーブルの中身を確認すると，insertできていることがわかる．</p>

<pre><code>$ sqlite3 /tmp/test.db
SQLite version 3.7.13 2012-07-17 17:46:21
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite&gt; .schema load01
CREATE TABLE load01(`id` integer,`account` integer,`time` text,`purchase` text,`comment` text);
sqlite&gt; select * from load01;
1|32864|2015-01-27 19:23:49 UTC|2015-01-27 00:00:00 UTC|embulk
2|14824|2015-01-27 19:01:23 UTC|2015-01-27 00:00:00 UTC|embulk jruby
3|27559|2015-01-28 02:20:02 UTC|2015-01-28 00:00:00 UTC|embulk core
4|11270|2015-01-29 11:54:36 UTC|2015-01-29 00:00:00 UTC|Embulk "csv" parser plugin
sqlite&gt;
</code></pre>

<h1>まとめ</h1>

<p>embulk自体がjrubyで書かれており，pluginでC拡張のgemは使えないみたい．<br/>
なので，DB接続する場合はjdbc-sqlite3などのgemを使うことになる．(間違ってたら指摘お願いします)<br/>
あと，pluginの作り方のベスト・プラクティスがまだわからない．</p>

<h1>参考</h1>

<ul>
<li><a href="https://github.com/embulk/embulk">embulk/embulk</a></li>
<li><a href="http://dev.classmethod.jp/tool/embulk-ataglance/">Treasure Dataの新データ転送ツールEmbulkを触ってみた #dtm_meetup ｜ Developers.IO</a></li>
<li><a href="http://www.slideshare.net/frsyuki/embuk-making-data-integration-works-relaxed">Embulk, an open-source plugin-based parallel bulk data loader</a></li>
<li><a href="https://github.com/frsyuki/embulk-plugin-postgres-json">frsyuki/embulk-plugin-postgres-json</a></li>
<li><a href="https://github.com/takebayashi/embulk-plugin-input-hbase">takebayashi/embulk-plugin-input-hbase</a></li>
<li><a href="https://github.com/jruby/activerecord-jdbc-adapter">jruby/activerecord-jdbc-adapter</a></li>
<li><a href="https://bitbucket.org/xerial/sqlite-jdbc/overview">xerial / sqlite-jdbc — Bitbucket</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[facebook graph apiのAccess Tokenを取得するまで]]></title>
    <link href="http://takady.github.io/blog/2014/12/29/facebook-graph-api-oauth-flow/"/>
    <updated>2014-12-29T17:45:20+09:00</updated>
    <id>http://takady.github.io/blog/2014/12/29/facebook-graph-api-oauth-flow</id>
    <content type="html"><![CDATA[<p>OAuth2について、わかってたつもりでわかってないので、<br/>
<a href="https://github.com/nov/fb_graph">nov/fb_graph</a>を通して、facebook graph apiでAccess Tokenを発行するところまでを追ってみた</p>

<h1>TL;DR</h1>

<p>この面倒なtoken生成作業は、<a href="https://developers.facebook.com/">https://developers.facebook.com/</a>のTools > Graph API Explorerで、<br/>
Get Access Tokenとボタンを押すと生成できるので、すぐtokenを生成したいのなら、下記を読まずにそこから生成するのが楽で良い</p>

<h1>1.まずfacebookにappを登録</h1>

<p><a href="https://developers.facebook.com/">https://developers.facebook.com/</a>のApps > Add a New Appで作成できる<br/>
この時、リダイレクト先URLも下記から設定しておくこと<br/>
Settings > Advanced > Security > Valid OAuth redirect URIs</p>

<h1>2.App IDとApp Secretを確認</h1>

<p>先ほど作成したAppのDashboardに行って確認できる</p>

<h1>3.client_idとredirect_url付きのGETリクエストを送信</h1>

<p>下記のようにリクエストする</p>

<pre><code>GET https://graph.facebook.com/oauth/authorize?client_id=&lt;Your App ID&gt;&amp;redirect_uri=&lt;Your Redirect URL&gt;
</code></pre>

<h1>4.リダイレクトされたurlのAuthorization Codeパラメータの値を確認</h1>

<p>下記のような感じである</p>

<pre><code>http://example.com?code=&lt;Your Authorization Code&gt;
</code></pre>

<h1>5.POSTリクエストを送信してAccess Tokenを取得</h1>

<p>取得したAuthorization Codeを含め、パラメータとして下記をセットしてPOSTでリクエストする</p>

<pre><code>POST https://graph.facebook.com/oauth/access_token

 grant_type: authorization_code
 code: &lt;Your Authorization Code&gt;
 redirect_uri: &lt;Your Redirect URL&gt;
 client_id: &lt;Your App ID&gt;
 client_secret: &lt;Your App Secret&gt;
</code></pre>

<p>レスポンスのbodyは下記のようになっている</p>

<pre><code>access_token=&lt;Your Access Token&gt;  
</code></pre>

<p>この生成されたaccess_tokenを使って、facebook graph apiを利用する事ができる</p>

<h1>6.Access Tokenの有効期限を伸ばす</h1>

<p>facebook graph apiの場合、このままだとAccess Tokenの有効期限が短すぎる<br/>
下記のGETリクエストを送ることで、有効期限を60日間に伸ばす事ができる</p>

<pre><code>GET https://graph.facebook.com/oauth/access_token?grant_type=fb_exchange_token&amp;client_id=&lt;Your App ID&gt;&amp;client_secret=&lt;Your App Secret&gt;&amp;fb_exchange_token=&lt;Your Access Token&gt;  
</code></pre>

<h1>まとめ</h1>

<p>OAuth2、Access Token取得後はそれだけでAPIとやりとりできるからシンプルで良いけど、Access Tokenを取得するまでがめんどくさい<br/>
ブラウザ無しでtoken発行やりたかった(<a href="https://github.com/nov/fb_graph/wiki/Authentication#javascript-sdk">Javascript SDK</a>使ったらできるのか?)<br/>
Facebookでは上記フローだが、twitterとかgithubとか他のサービスもまったく同じなわけじゃないので、他も触ってみたい</p>

<h1>参考</h1>

<p><a href="http://stackoverflow.com/questions/21978728/obtaining-a-facebook-auth-token-for-a-command-line-desktop-application">ruby - Obtaining a Facebook auth token for a command-line (desktop) application - Stack Overflow</a><br/>
<a href="http://rebuild.fm/43/">Rebuild: 43: Kent is More Professional (Kenn Ejima)</a><br/>
<a href="https://github.com/nov/fb_graph/wiki">Home · nov/fb_graph Wiki</a><br/>
<a href="http://morizyun.github.io/blog/facebook-event-api-ruby-fb_graph/">公開中のFacebook EventをGraph APIから取得する - 酒と泪とRubyとRailsと</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[rubyのloggerをnewした後にログファイルを削除するとどうなるのか]]></title>
    <link href="http://takady.github.io/blog/2014/12/07/file-safe-logger/"/>
    <updated>2014-12-07T18:01:52+09:00</updated>
    <id>http://takady.github.io/blog/2014/12/07/file-safe-logger</id>
    <content type="html"><![CDATA[<p><strong>この投稿は<a href="http://qiita.com/advent-calendar/2014/ruby">Ruby Advent Calendar 2014</a>の7日目の記事です。</strong></p>

<p>rubyには標準添付ライブラリにloggerクラスがある。<br/>
そのloggerクラス、newした後に出力先のログファイルが削除された時の挙動について調べた。<br/>
そして、<a href="https://github.com/takady/file_safe_logger">file_safe_logger</a>というgemを作った。</p>

<h1>検証</h1>

<p>下記のようにして、<code>Logger.new</code>と<code>logger.info</code>の間でファイルを削除してみる</p>

<pre><code class="ruby">require 'logger'
require 'fileutils'

logfile = 'test.log'
logger = Logger.new(logfile)
FileUtils.rm(logfile)
logger.info('this is test')
</code></pre>

<p>これは、結果としてはエラーにはならず正常終了するが、test.logというファイルはカレントディレクトリに存在せず、もちろん<code>this is test</code>というlogも残っていない。</p>

<h1>FileSafeLogger</h1>

<p>ファイルが削除されるとlogging出来ないというのが困る時がある。<br/>
なので、<a href="https://github.com/takady/file_safe_logger">file_safe_logger</a>というgemを作った。<br/>
やってることはいたって単純で、<a href="https://github.com/ruby/ruby/blob/trunk/lib/logger.rb#L593-L612">Logger::LogDevice.#write</a>メソッドをoverrideして、ファイルが存在しない場合は作成しているだけである。<br/>
<a href="https://github.com/takady/file_safe_logger">file_safe_logger</a>を使って、先ほどのlogging処理と同じ処理をやってみる。</p>

<pre><code class="ruby">require 'file_safe_logger'
require 'fileutils'

logfile = 'test.log'
logger = FileSafeLogger.new(logfile)
FileUtils.rm(logfile)
logger.info('this is test')
</code></pre>

<p>これの実行後、カレントディレクトリには<code>test.log</code>が存在し、下記のようにlogが書き出されている。</p>

<pre><code>$ cat test.log
# Logfile created on 2014-12-06 17:07:53 +0900 by logger.rb/44203
I, [2014-12-06T17:07:53.884806 #1547]  INFO -- : this is test
</code></pre>

<h1>参考</h1>

<p><a href="https://github.com/sonots/process_safe_logger">sonots/process_safe_logger</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[turnipを使ってシナリオテストを自動化]]></title>
    <link href="http://takady.github.io/blog/2014/11/26/turnip/"/>
    <updated>2014-11-26T19:17:48+09:00</updated>
    <id>http://takady.github.io/blog/2014/11/26/turnip</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/jnicklas/turnip">turnip</a>は、シナリオテストを自然言語風のDSLで記述・実行させることができるruby製のツールです。<br/>
ここでは、wikipediaを開いて「カブ」を検索するというシナリオを例にしてみます。</p>

<h1>事前に</h1>

<p>webページの操作には<a href="https://github.com/jnicklas/capybara">Capybara</a>を使います。<br/>
今回はrackアプリではないので、HTTP通信を行うためのdriverを別途用意する必要があります。<br/>
今回は比較的導入が楽でありHeadless(GUIを必要としない)ドライバであるPhantomJSを利用します。<br/>
OSXであれば、下記でインストールできます。</p>

<pre><code>$ brew install phantomjs
</code></pre>

<h1>準備</h1>

<p>まずディレクトリを用意しましょう。<br/>
今回は、railsなどとは組み合わせず、シンプルにturnipだけを使います。</p>

<pre><code>$ mkdir turnip_sample
$ cd !$

$ bundle init
</code></pre>

<p>Gemfileに下記を記載し、<code>bundle install</code>を実行します。</p>

<pre><code class="ruby">source "https://rubygems.org"

gem 'turnip'
gem 'capybara'
gem 'poltergeist'
</code></pre>

<p>rspecとturnipの設定ファイルを用意します。</p>

<pre><code>$ rspec init
$ echo '-r turnip/rspec' &gt;&gt; .rspec
</code></pre>

<p><code>spec/turnip_helper.rb</code>を下記の内容で作成します。
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="n">turnip</span><span class="o">/</span><span class="n">capybara</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span>
</span><span class='line'><span class="nb">require</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="n">capybara</span><span class="o">/</span><span class="n">poltergeist</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;Capybara.default_driver = :poltergeist&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span><span class="no">Dir</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">spec</span><span class="o">/&lt;</span><span class="n">em</span><span class="o">&gt;*/&lt;</span><span class="sr">/em&gt;steps.rb&amp;rdquo;) { |f| load f, true }</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>これで、turnipでwebアプリのシナリオテストを書く準備が整いました。</p>

<h1>featureファイル</h1>

<p>featureファイルを下記の内容で作成します。</p>

<p>spec/features/sample.feature</p>

<pre><code class="Text">Feature: 検索する

  Scenario: wikipediaでカブを検索する
    Given wikipediaトップページにアクセスする
    When wikipediaトップページを表示する
    Then ウィキペディアへようこそと表示されている
    And searchにカブを入力する
    And searchButtonボタンをクリックする
    Then アブラナ科アブラナ属の越年草と表示されている
</code></pre>

<p>featureファイルは、いわゆるテストシナリオの定義ファイルです。<br/>
自然言語で書ける(日本語にも対応している)ため、非エンジニアにとっても理解しやすいと思います。</p>

<h1>stepファイル</h1>

<p>stepファイルを下記の内容で作成します。</p>

<p>spec/steps/sample_step.rb</p>

<pre><code class="ruby">step 'wikipediaトップページにアクセスする' do
  Capybara.app_host = "http://ja.wikipedia.org"
end

step 'wikipediaトップページを表示する' do
  visit '/'
end

step %(:textと表示されている) do |text|
  expect(page).to have_content(text)
end

step %(:fieldに:valueを入力する) do |field, value|
  fill_in field, with: value
end

step %(:textボタンをクリックする) do |text|
  click_button text
end
</code></pre>

<h1>テスト実行</h1>

<p>無事にテストが通過するはずです。</p>

<pre><code>$ rspec
JQMIGRATE: Logging is active
JQMIGRATE: Logging is active
.

Finished in 5.6 seconds (files took 0.29979 seconds to load)
1 example, 0 failures
</code></pre>

<h1>featureファイルとstepファイルの関係</h1>

<p>featureファイルが自然言語風なDSLなのでイメージしにくいかもしれませんが、featureファイルから、stepファイルに定義したメソッド(実際にはstep)を呼び出している、と考えるとわかりやすいかと思います。<br/>
上記の例ですと、<br/>
featureファイルの<code>Then ウィキペディアへようこそと表示されている</code>という記述で、stepファイルの、<code>step %(:textと表示されている)</code>のstepが呼ばれます。<br/>
<code>:text</code>とすることで、そこに入る文字列を動的に指定出来て汎用的になります。</p>

<h1>参考</h1>

<p><a href="http://magazine.rubyist.net/?0042-FromCucumberToTurnip">Rubyist Magazine - エンドツーエンドテストの自動化は Cucumber から Turnip へ</a><br/>
<a href="http://techracho.bpsinc.jp/hachi8833/2014_06_26/18068">[RSpec][Turnip] 一般的に使えるTurnipステップ集 | TechRacho</a><br/>
<a href="http://gongo.hatenablog.com/entry/2013/05/29/223218">Turnip について (1) / まずは動かす - Thanks Driven Life</a><br/>
<a href="http://orangain.hatenablog.com/entry/turnip">Ruby製アプリじゃなくてもTurnipで自動受け入れテストがしたい - orangain flavor</a><br/>
<a href="http://qiita.com/moriyaman/items/af2a0264adbaaa0d2029">Rails + Turnip + Capybara + poltergeistでBDDテスト - Qiita</a><br/>
<a href="http://tmpla.info/installation-of-capybara-webkit/">Capybara WebkitをCentOSで使えるようにする方法 – 日本の天ぷら情報</a><br/>
<a href="http://qiita.com/take/items/779747e0981355e569ad">poltergeist - Capybaraを使う際に知っておきたいこと - Qiita</a></p>
]]></content>
  </entry>
  
</feed>
